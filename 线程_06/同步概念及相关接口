1.同步概念：
   在保证数据安全的前提下，让线程能够按照某种特定的顺序访问临界资源，从而有效的避免饥饿问题。(保证了各个执行流对临界资源访问的合理性)
	
	同步实现的事情：
	  当有资源的时候，可以直接获取资源，没有资源的时候线程等待，等待另一个线程生产资源，当生产好以后，通知等待线程

2.条件变量：
  本质 = 两个接口(等待接口+唤醒接口)+PCB等待队列

  例子：
     执行流-顾客(用碗吃面) 执行流-厨子(做面) 临界资源-碗
    
   对于执行流-顾客：
	 碗里没有面：顾客发现碗里没有面，则该执行流调用条件变量的等待接口将该执行流的PCB放到PCB等待队列中，等待厨子做完面之后通知PCB
	       有面：正常吃面，调用条件变量的唤醒接口，通知PCB等待队列当中的厨子来做面
   
   对于执行流-厨子：和顾客类比即可（不做赘述）

   该形象的例子对应到Linux系统当中来：
     顾客--》消费线程
	 厨子--》生产线程
	 碗--》相当于临界资源，只不过这个临界资源可能被生产和消耗

3.条件变量的接口：
   
   1.定义条件变量
     pthread_cond_t 条件变量类型
   
   2.初始化条件变量：
     动态：（需要调用销毁接口）
	  pthread_cond_init(pthread_cond_t* cond,pthread_condattr_t* attr);
       cond:传入的条件变量的变量地址
	   attr:条件变量属性，一般设置为NULL

	 静态:(不需要调用销毁接口)
	  pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

   3.等待接口：将调用该等待接口的执行流放到PCB等待队列中，进行等待
      pthread_cond_wait(pthread_cond_t* cond,pthread_mutex_t* mutex);
	 
   4.唤醒接口：通知PCB等待队列当中的执行流来进行访问临界资源
      int pthread_cond_signal(pthread_cond_t* cond);--》唤醒至少一个PCB等待队列当中的线程
      int pthread_cond_broadcast(pthread_cond_t* cond);--》唤醒所有PCB等待队列 当中的线程
	
	5.销毁 (释放动态初始化的条件变量所占用的内存)
	  int pthread_cond_destroy(pthread_cond_t* cond);


	/*
	   对于顾客：
	     1.先加互斥锁
		 2.判断碗里是否有面 / 没面
		 3.吃面 / 使用wait接口等待，进入PCB等待队列
		 4.解锁  / （无面就到不了这一步）
		 5.唤醒厨子 /  （无面就到不了这一步）

		对于厨子： 同养的机制 只不过最终是唤醒顾客 （具体无需赘述）

	*/

**为什么要使用互斥锁？
  如果单纯的同步，不保证互斥，也就意味着不同的执行流可以在同一时刻去访问临界资源，所以在条件变量中需要使用互斥锁来保证互斥属性，保证各个执行流在同一时刻访问临界资源的时候，只有一个执行流在访问。
  条件变量当中的互斥锁是一个道理，也是保证了各个执行流在访问临界资源的时候，只有一个执行流可以访问，从条件变量的实用角度而言，还完成了生产线程和消费线程之间的互斥

**pthread_cond_wait(...)函数当中的实现逻辑，如何来使用互斥锁？
  1.将调用者的PCB放到PCB等待队列中去
  2.对互斥锁进行解锁操作
  3.等待其他执行流通知PCB等待队列，被唤醒后，移出PCB等待队列，进而执行抢锁操作     没有抢到互斥锁：卡在抢互斥锁的逻辑当中
     抢到互斥锁：拥有了可以访问临界资源的资格

生产者与消费者模型：
  123规则： 1个场所(队列)+两种角色(消费者和生产者)+三种关系(消费者与消费者互斥+生产者与生产者互斥+消费者和生产者同步互斥)

  优点：
    可以解耦合： 生产者和消费者都是通过队列进行交互（当生产时只需要考虑是否需要生产，消费时只需要考虑是否有资源可消费）
	支持忙闲不均：队列起到了一个缓冲的作用（生产者可以一直生产，这样消费者来了就可以直接进行消费）
	支持并发：消费者只关心队列中是否有数据可以进行消费
	          生产者只关心队列当中是否有空闲结点可以进行生产
