局域网 城域网 广域网

计算机网络当中两台计算机怎么进行通信?
	IP地址：在网络中唯一标识一台主机
	PORT：端口在一台主机上标识一个进程

网络协议：为计算机网络中进行数据交换而建立的规则、标准或约定的集合。
	计算机网络中是有很多网络协议的，将许多网络协议联系在一起，称之为协议簇
（TCP/IP）

协议分层:
	协议分层就是一种封装，对不同的协议或者服务进行封装
	
	OSI参考模型（工业上没有使用，分层很细，但是有参考价值）：
		物理层 数据链路层 网络层 传输层 会话层 表示层 应用层

	TCP/IP五层模型：
		物理层、数据链路层、网络层、传输层、应用层

		应用层：负责应用程序之间的数据传输，程序员就是工作在这一层面的
			典型的协议：HTTP协议，FTP协议，DNS协议

		传输层：负责端与端之间的数据传输
			典型协议：TCP协议、UDP协议

		网络层：负责路由选择和地址管理
			典型协议：IP协议、ARP协议、ICMP协议 
			典型设备: 路由器

		数据链路层：负责相邻设备之间的数据帧传输
			典型协议：以太网协议(Ethernet)
			典型设备：交换机

		物理层：负责光电信号的传输
			典型协议：以太网协议 
			典型设备：集线器

ip地址：
	a.作用：在网络中唯一标识一台主机
	b.本质：uint32_t值，无符号4个字节--》ipv4已经枯竭
	c.源ip地址和目的ip地址

	网络通信中，每一条数据都需要具备5个信息：
		源IP+源端口+目的IP+目的端口+protocol

端口(port)：
	1.端口是在一台主机中标识一个进程
	
	2.本质：uint16_t端口的范围0~2^16（0-65535）其中0~1023是知名端口
	mysql---3306 oracle---1521

	3.使用：
		网络当中的程序，通信的时候，都需要使用端口进行通信。


客户端和服务端的概念是相对的：
	客户端：主动发起请求的一方，称之为客户端

	服务端：被动的固定在同一个位置上接受请求的一方，称之为服务端

为什么不适用PID作为请求与主机当中查找进程的标准呢？
	

字节序：CPU对内存当中的数据进行存取的顺序
	大端字节序:低地址存高位
	小端字节序:低地址存低位
    
	例子：  a = 0x01020304
	           高位      低位

		      低地址      高地址
        大端：01 02 03 04
		小端：04 03 02 01
    如何确认一台机器是大端字节序还是小端字节序？
	  x86_64架构的机器都是小端机器

网络字节序：大端字节序
	小端机器和打断机器进行网络通信的时候，如果不转换字节序，则会造成小端
	机器很小的数字，经过网络传输，被大端机器读出来变成一个很大的数字。

字节序转换:
	大端字节序转换成网络字节序--》网络字节序本身就是大端字节序
	小段字节序转换成网络字节序：
	uint32_t htonl(uint32_t hostlong);主机字节序转换为网络字节序（小转大）
	
	uint32_t htonl(uint32_t netlong);网络字节序转换为主机字节序
    
	（将以上端口的32改为16 htonl改为htons 即是16位无符号数的网络字节序与主机字节序之间
	的互相转换的接口）

TCP与UDP协议的区别：
	TCP： 
		面向连接：tcp通信双方在发送数据之前，需要先建立连接，才可以发送数
		据；
		可靠传输：保证tcp数据包可靠的到达对端
		面向字节流：对于tcp数据可以随意的存取

	UDP：
		无连接：udp通信双方在发送数据之前，不需要建立连接，只需要知道对方
		的ip和port就可以直接发送数据了
		不可靠：如果udp数据在网络传输过程中，丢失掉了，则不会保证udp数据一
		定到达对端了
		面向数据报：udp在发送数据的时候是整条发送整条接收的
  
UDP通信流程&UDP编程套接字接口：
	
	client(客户端)：
		1.创建一个套接字
		2.绑定地址信息
			一般情况下，不让客户端程序绑定地址信息，让操作系统默认分配一个
			空闲端口。（因为一个端口只能被一个进程所绑定，若有两个相同的进
			程请求服务，就会冲突）
		3.发送数据
		4.接收数据

	server(服务端)：
		1.创建一个套接字：将创建出来的套接字的进程和网卡尽力练习，
		struct socket{...};
 
        2.绑定地址信息：port+ip
			将端口和进程联系起来。port表明服务器进程在哪个端口上侦听数据；
			ip表明服务端进程在哪一个网卡接收数据；
		3.接受数据
		4.发送数据

socket编程接口：
	1.创建套接字：
		int socket(int domain,int type,int protocol);
			domain:地址域，设置网络层使用什么协议
				网络层： ipv4-》AF_INET
							ipv6-》AF_INET6
			type：套接字类型
				传输层：tcp/udp
					流式套接字:默认协议是tcp，不支持udp的-》SOCK_STREAM
					数据报套接字：默认协议是udp，不支持tcp-》SOCK_DGRAM
			protocol：指定套接字所使用的协议
				0：采用套接字默认类型
				IPPROTO_TCP --> 6
				IPPROTO_UDP -->17
        返回值：
			返回套接字的操作句柄，其实就是一个文件描述符，我们一般称之为套
			接字描述符

	2.绑定端口号：
		int bind(int sock,const struct sockaddr* addr,socklen_t address_len
		);
		sock：套接字操作句柄
		addr：地址信息 ip+port 
		address_len: 地址信息长度，防止有的协议的地址信息长度大于16个字节，
		所以传递地址信息长度，告诉bind函数，应该如何去解析地址信息。

		bind接口在设计的时候为了通用各种协议定义了一个结构体struct sockaddr
		，而在进行具体协议地址信息绑定的时候，填充不同的结构体，之后将结构
		体的对象的地址，强转传参给bind函数
	
    3.监听：
		int listen(int socket,int backlog);

	4.接受请求：
	int accept(int sock,const struct sockaddr* addr,socklen_t address_len);
		
	5.建立连接(TCP,客户端)
	int connect(int sockfd,const struct sockaddr* addr,socklen_t address_len);
	 
    6.发送数据：
		ssize_t sendto(int sockfd,const void* buf,size_t len,int flags,cons
	    t struct sockaddr* dest_addr,socklen_t addrlen);
    sockfd:套接字描述符
	buf：待发送数据
	len：发送的数据长度
	flags：
		0:阻塞发送
	dest_addr:目标主机地址信息
	addrlen：地址信息长度

	
	                                               
       
