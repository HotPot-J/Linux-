TCP编程流程：
	服务端:
      准备阶段：
		1.创建套接字（socket）
		2.绑定地址信息（bind）
		3.监听
			告知操作系统当前程序可以正常的接收连接了，内核行为。三次握手也是
			在监听的时候内核完成的。
		4.获取连接
			获取已经完成三次握手的连接
----------------------------------------------------------------------------
		
		5.接收数据
		6.发送数据
		7.关闭套接字

	客户端：
	  准备阶段：
		1.创建套接字
		2.（绑定地址信息）
		3.发起连接
----------------------------------------------------------------------------		
		4.发送数据
		5.接收数据
		6.关闭套接字

数据收发过程，当tcp连接建立之后，不在乎谁先发送数据，两者都是可以直接发送数据
的。


TCP编程接口：
	
	创建套接字 ---》socket
	绑定地址信息 ---》bind

	监听:
		int listen(int sockfd,int backlog);
		sockfd:套接字描述符
		backlog：已完成连接队列的大小，backlog可以指定已完成连接的队列大小，
			     如果当已完成连接队列满了，处理方式就是丢弃新来的连接；
				 使用接收新连接，从已完成连接队列当中获取创建完成的新连接
			已完成连接队列：三次握手完成后的连接 会被放在这个队列中
			未完成连接队列：还处于三次握手当中的tcp连接

	接收连接：
		int accept(int sockfd,struct sockaddr* addr,socklen_t* addlen);
		sockfd:侦听sockfd；从侦听sockfd接收新的连接请求
		addr：客户端地址信息
		addrlen：客户端地址信息的长度
		返回值：
			返回新创建出来的socket，通过新创建出来的socket和客户端进行数据收
			发；
		注意：因为该接口是从已完成连接队列当中获取新的连接，所以，当已完成连
		队列当中没有已完成的新的连接的时候，该接口如果调用就会阻塞；直到获取
		一个新的已完成连接到来。

	为什么需要新创建出来的socket和客户端进行通信？
		如果只有一个socket，则无法同时与多个客户端进行通信。

  建立连接（客户端）
  int connect(int sockfd,const struct sockaddr* addr,socklen_t address_len)；
   sockfd:套接字描述符
   addr：服务端地址信息，需要自己在代码当中填充好，传递给connect
   addlen:地址信息长度

   关闭套接字：
	close(int sockfd);
