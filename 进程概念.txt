1.进程概念
    a.冯诺依曼体系结构 （二进制/存储思想）中央处理器cpu 存储器内存 输入/输出设备
	     
操作系统 
      操作系统是一个软件
	  操作系统= 操作系统内核+一组应用 
	  操作系统是管理计算机的软硬件资源的软件

      系统调用： 指的是操作系统提供的函数，称之为系统调用的函数	
库函数： 封装了系统调用函数 提供了一些封装后的函数共程序员使用，被封装的函数称之为库函数

操作系统具体是如何进行管理计算的软硬件资源的

管理 = 描述 + 组织方式 

操作系统是如何管理进程的： 描述+组织的方式
    1. struct task_struct  （描述）
	
进程模块 
程序是一个文本文件，程序是静态的
进程是程序执行起来的一个实体（要创建一个task_struck的结构体）

task_struct>>PCB：（进程控制块）          # find /usr -name sched.h 可以找到源码 用vim打开即可查看
pid：进程标识符    
进程状态：就绪状态 阻塞状态 运行状态
内存指针：执行一个mm_struct:该指针指向程序地址空间
程序计数器：保存程序执行的下一条指令
上下文信息：保存寄存器的值

记账信息：
      cpu密集型程序： 程序大量的时间都在使用cpu进行计算
	  IO密集型程序：程序大量时间都在和磁盘打交道，进行IO
	  抢占式执行
	  并发并行： 在同一时间，多个进程，每一个进程都拥有

操作系统是如何管理进程的：描述+组织方式

组织： 
     操作系统是使用双向链表来组织进程的
	 
通过系统调用创建进程：

    子进程和父进程：一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有
子进程的进程ID。 而且父子进程也会抢占是执行
    一个进程只会有一个父进程，所以任意一个子进程都可以通过调用getppid()函数来获取其父进程的ID
	
    **fork函数：同过系统调用创建一个一模一样的子线程，[用来处理请求信号，而父进程继续一直处于监听状态。---靠进程并发的原理]
	     头文件：#include<unistd.h>
	       pid_t fork(void); 由fork函数创建的新进程被称为子进程 
	返回值为 pid_t===>int类型 
	 创建子进程失败：返回-1 
	 fork失败的原因：没有足够的内存 创建PCB是需要耗费内存的 这个内存的内核空间内存
	               因为PCB内创建出来更不用谈进程地址空间了 所以是由于内核空间不足的原因导致fork失败！
               成功：
                    在子进程中： 返回0给 返回给子进程
                    在父进程中：返回大于0（返回子进程的pid） 给父进程
	
	函数说明：
	    fork()函数调用成功后，将为子进程申请pcb和用户内存空间。子进程是父进程的副本。
	在用户空间将复制父进程用户空间所有数据（代码段、数据段、BBS、堆、栈），复制
	父进程内核空间PCB中绝大多数信息。子进程从父进程继承下列属性:有效用户、组号
	进程组号、环境变量、对文件执行时关闭标志、信号处理方式设置、信号屏蔽集合、当前
	工作目录、根目录、文件模式掩码、文件大小限制和打开的文件描述符（特别注意：共用同一文件表项）
	    子进程在创建后和父进程同时执行，竞争系统资源，谁先谁后，取决于内核所使用调度算法。
	子进程的执行位置为fork返回位置
	
	**getpid：获取当前进程的pid，我们要使用getpid  pid_t getpid(void)
	  getppid：获取当前进程的父进程的pid，我们要使用getpid  pid_t getppid(void)
	  

	   