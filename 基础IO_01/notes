1.系统调用文件操作

a. int open(const char* pathname,int flags,mode_t mode)
	pathname:待打开文件的路径+文件描述符
	flag:以何种方式打开 
	必选项：（且三者只能选其一）
	     O_RDONLY:只读
		 O_WRONLY:只写
		 O_RDWR：可读可写
	可选项:(可选择多个)
		 O_CREAT:如果不存在则创建文件
		 O_TRUNC:截断文件（清空）
		 O_APPEND:以追加方式打开
		#include<fcntl.h>以上宏都在该头文件中
	mode:对于新创建出来的文件，设置文件权限
	返回值:返回文件描述符

b. ssize_t write(int fd,const void* buf,size_t count)
	fd:文件描述符
	buf:写入数据
	count:写入数据大小

c. ssize_t read(int fd,const void* buf,size_t count)
	fd:文件描述符，从哪里进行读
	buf:读到那里去
	count:最多可以读多少字写，注意：预留\0位置

d. off_t lseek(int fd,off_t offset, int whence)
	打开下一个文件的下一次读写位置
	fd:需要操作的文件描述符
	offset:偏移量
	whence:偏移到哪里去
	whence: SEEK_SET(文件指针开始) SEEK_CUR(文件指针当前位置)
	SEEK_END(文件指针尾)

e. close(int fd)

2.写一个系统调用版的文件操作代码---> 见本文件下test1.c

3.文件描述符：
	每个进程都有一个指针*file，指向一张表files_struct，该表最重要
	部分就是包含一个指针数组，每个元素都是一个指向打开文件的指针，
	（每个打开文件，在内核当中都有file对象，保存了文件相关的信息
	比如：文件创建时间、权限大小、磁盘存储位置等等）
	所以实质上，文件描述符就是该数组的下标。所以只要拿到文件描述符
	就可以找到对应文件。（下标证明文件描述符是一个正整数！）
	0号下标---》标准输入
	1号下标---》标准输出
	2号下标---》标准错误

	

文件描述符的分配规则：最小未占用规则（未被占用的最小下标）


文件描述符与文件流指针的关系:
文件流指针是库函数中用来识别文件的  文件描述符是系统调用中用来识别文件的

	1.读写缓冲区是库函数维护的，并非内核维护的
	2.进程终止中，刷新缓冲区就剩操作该缓冲区。
	_exit（系统调用）& exit（库函数）：后者会刷新缓冲区（库函数维
	护的缓冲区），前者不会刷新缓冲区（_exit是内核代码）。
	3.为什么使用文件流指针的时候，打印内容时，如果不加\n或者其他强
	制刷新缓冲区的操作，就不会立即打印到屏幕上?
		由于打印的内容是先写到写缓冲区中。只有刷新或者超过缓冲区
		才会到标准输出中去。
	4.不管是使用文件流操作打开文件或者打开标准文件流，都是在c库中
	创建一个struct_IO_FILE结构体。每一个文件或者每一个标准文件流，
	都对应一个struct_IO_FILE(包含读缓冲区 写缓冲区 _fileno(保存文
	件描述符))


