父进程：1.接收新的连接 2.创建子进程

客户端请求连接，父进程创建新套接字 再fork一个子进程 让子进程与之通信
(不让父进程在接受新连接之后，拿着新创建的socket和发起请求的客户端进行通
 信，而是fork子进程，让子进程去和该客户端进行通信，而父进程继续等待其他客
 户端的请求，即可实现多个客户端与一个服务器进行交互)

// 进程相关接口：#include<unistd.h>
	
	创建子进程:pid_t fork(void);
	返回值：子进程中返回0，父进程返回子进程id，出错返回-1
	
	进程调用fork()后，当控制转移到内核中的fork代码后，内核：
		1.分配新的内存块和内核数据结构给子进程
		2.将父进程部分数据结构拷贝至子进程
		3.添加子进程到系统进程列表当中
		fork返回，开始调度器调度
	fork常规用法：一个父进程希望复制自己，使得父子进程同时执行不同的代码段
	。（例如，父进程等待客户端请求，生成子进程来处理请求）

	fork调用失败的原因：系统中有太多进程。
						实际用户的进程数超过了限制

    
	进程终止:
		进程退出场景：1.代码运行完毕，结果正确/不正确。3.代码异常终止

		正常终止：1.从main返回 2.调用exit
		异常退出：ctrl+c
	
		exit函数：void _exit(int status);
		参数：status定义了进程的终止状态，父进程通过wait来获取该值

		_exit函数：void exit(int status);
		 其终止进程的流程:执行用户定义的清理函数，冲刷缓冲区，关闭流等
		
		 (exit(0)/_exit() 表示正常退出)
		 (exit(1)/_exit() 表示异常退出)
	进程等待:
       必要性：
		1.子进程退出，父进程不管不顾，则会造成僵尸进程的问题，进而内存泄漏
        2.进程变成僵尸状态，就无法被杀死。
		3.我们需要知道父进程派给子进程的任务完成的如何。
		4.父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息。

		方法:
			#include<sys/types.h>
			#include<sys/wait.h>
			pid_t wait(int* status);
			返回值：
				成功返回所等待进程的pid，失败返回-1
				参数：输出型参数，获取子进程退出状态，不关心则可设置为NULL
             （调用wait会导致父进程陷入阻塞状态，直到有任一个子进程退出，
			 则执行wait的逻辑之后退出。）

		阻塞：当调用函数需要等待一定条件成熟的时候，如果当条件不成熟
		   则一直等待.否则执行完函数逻辑之后正常退出。
		非阻塞: 当调用函数需要等待一定条件的的时候，如果该条件不成熟，则直
		接返回，如果该条件成熟，则执行完后再返回。
		
		获取status(状态)：
			wait和waitpid都有status参数，该参数为输出型参数，由操作系统填
			充。操作系统会根据该参数，将子进程的退出信息反馈给父进程。

			status参数不能简单地当int看待，可以当位图看待：
			正常终止：15位------8位 7位------0位
			             退出状态       全0

			被信号所杀：  未用          终止信号


	   进程程序替换：#include<unistd.h>
		替换原理:用fork创建子进程后执行的是和父进程相同的程序(也有可能执行
		不同的代码分支)，子进程往往需要调用一种exec(执行)函数以执行另一个
		程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新
		程序替换，从新程序的启动开始执行。调用exec并不创建新进程，所以调用
		exec前后该进程的id并未改变。

		int execl(const char* path,const char* arg...);

		exec后边加
			l：表示采用参数列表
			v：采用参数数组
            lp/vp：有自动搜索环境变量path
			le/ve：表示自己维护环境变量

			




