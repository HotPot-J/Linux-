死锁：
  死锁是指在一组进程中的各个进程均占有不会释放的资源，但是因相互申请被其他进程所占用不会释放的资源而处于一种永久等待状态。
  
  1.  程序当中有一个执行流没有释放锁资源，会导致其他想要获取该互斥锁的执行流陷入阻塞等待，这种情况称之为死锁。
  
  2.程序当中，每一个执行流都占有一把互斥锁，但是由于各个执行流在占有互斥锁的情况下，还想申请对方的锁，这种情况我们称之为死锁。
   例： 执行流A---》拿到互斥锁1   还想要去获取互斥锁2
        执行流B---》拿到互斥锁2   还想要去获取互斥锁1

		此时，对于A而言已经获取了互斥锁1，但是还想要获取互斥锁2，在这种情况下由于互斥锁2被执行流B所占用，导致执行流A陷入阻塞等待，等待获取互斥锁2
		对于B而言，也是同样的情况
        会导致A,B两个执行流全部陷入阻塞等待，一旦陷入这样的死锁情况，就无法解决，除非重启程序(避免死锁之后重启程序)。

  3.gdb调试多线程的时候
  查看所有线程堆栈信息：thread apply all bt
  
  切换到某一个执行流：t+执行流编号

  在某一个执行流当中使用bt查看具体该执行流的调用堆栈
   f+对战编号 跳转到某一个具体堆栈

   **死锁的必要条件：
    互斥条件： 每一把锁只能被一个执行流所占用

	请求与保持条件：一个执行流因请求资源而阻塞时，对已获得的资源保持不放（吃着碗里的 看着锅里的）

	循环等待条件：若干个执行流之间形成一种头尾相接的循环等待资源的关系（类似于上述2.的情况）
   
	不剥夺条件：一个执行流以获得资源，在未使用完之前，必能强行剥夺。（只有当前拿着互斥锁的线程可以释放该资源）

   **避免死锁的方法：
   
   (1)破坏死锁的四个必要条件
    
   (2)加锁顺序一致：
	  线程A         线程B       互斥锁1 互斥锁2
	 先拿互斥锁1  先拿互斥锁1
	 再拿互斥锁2  再拿互斥锁2

   (3)避免锁不被释放

   (4)一次性分配资源：对于执行流在完成某件事情的时候，需要的资源，一次性分配够，防止需要的资源被其他加锁的线程所占用，导致该执行流阻塞
