2.进程状态：
   （*查看进程： ps aux | grep 进程名（或pid） ）
         R：运行状态
		       前台进程&后台进程
			   ./[可执行程序]&   将进程变为后台进程
			   fg 可以把一个进程放到前台来运行
	
         S：睡眠状态  （可被打断）
		 D：磁盘睡眠状态 （不可被打断）
		 T：暂停状态   （起来一个进程让它暂停的指令：ctrl+z）
		 t：跟踪状态  （调试的过程即为跟踪状态）
		 x：状态：死亡状态 进程终止的一瞬间叫做死亡状态
		 Z（zombie）：僵尸状态
		    僵尸状态是一个比较特殊的状态，当进程退出且父进程没有读取到子进程
		退出的返回代码时就会产生僵尸进程
		    将损失进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出
		状态码。
		    所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子
		进程进入z状态
		
		僵尸进程的危害：进程的推出状态必须被维持下去，因为他要告诉关心它的进程（父进程
		，你交给我的任务，我办的怎么样了，可是父进程一直不读取，那么子进程就一直处于z状态
		  
		  维护退出状态信息本身就是要用数据维护，也属于进程基本信息，所以保存在PCB中。
		 即，z状态一直不退出，PCB一直都要维护
		 
		 那一个父进程创建了很多子进程，就是不回收，会造成内存资源浪费
		 
		 如何解决过防止僵尸进程的产生?
		        1.可以将僵尸进程的父进程kill掉，则僵尸进程变成孤儿进程，就会有init来领养
			从而正常退出
		 
3.孤儿进程：
		   父进程先退出，子进程就称为“孤儿进程”
		   孤儿进程被1号init进程领养，当然要有init进程回收 然后孤儿进程就可以把自己的状态信息
		   返回给init进程