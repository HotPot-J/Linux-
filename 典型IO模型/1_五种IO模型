1.IO(input & output)过程：
  
  1.1等待IO就绪---》指想要获取的资源已经准备好了，可以进行操作
    读：recv/recvfrom ：想要获取的数据已经准备好了
    写:send/sendto：想要写入数据的空间已经准备好，可以写入数据了

  1.2拷贝数据到缓冲区中

*IO模型：

  一、阻塞IO：在内核将数据准备好之前，系统调用会一直等待，所有的
  套接字，默认都是阻塞方式。

  1.过程：
  （1）.应用进程发起IO调用，此时内核空间无数据报准备就绪。
  （2）.阻塞，等待数据报准备就绪
  （3）.当数据包准备就绪，将数据从内核拷贝到用户空间。
  （4）.拷贝完成后，IO调用返回。
  形象的说：（就如同抢票时，打开抢票界面（发起IO调用），眼睛盯着
  屏幕（阻塞等待），系统放票了（数据准备完毕），进行抢票（将数据
  从内核拷贝到用户空间））

  2.阻塞IO的特点：
      （1） 阻塞IO的方式，等待时长取决于内核
      （2） 在等待过程当中执行流是被挂起的，对CPU利用率很低
      （3） 在IO就绪到拷贝之间，实时性比较高（数据就绪立马就去拷
      贝）
      （4） 代码编写流程简单

  二、非阻塞IO：如果内核未将数据准备好，系统调用任然会直接返回，
  并且返回EWOULDBLOCK错误码（当前资源不可用）。
  如果返回资源不可用，也就意味着IO请求未被真正完成。

   1.在非阻塞的情况下，需要判断返回值，来判断IO请求被真正完成 ，
   需要搭配循环一直判断，直到IO请求完成。
  （有姜太公钓鱼的感觉--、没鱼上钩就拉勾，然后再抛鱼钩，如此往复
  直到钓到鱼）

   2.非阻塞IO的特点：
      （1）非阻塞IO对CPU的利用率比阻塞IO高
      （2）不够实时，IO准备就绪 到拷贝数据之间不够实时

  三、信号驱动IO：内核将数据准备好的时候，使用SIGIO信号通知应用程
  序进行IO操作。

    1.过程：
      （1）自定义信号处理函数
      （2）此时在内核中等待数据就绪后，递交给信号处理函数。
      （3）此时应用进程发起IO调用。
      （4）拷贝数据，返回成功指示。
       
    2.信号驱动IO的特点:
      （1) IO准备就绪 到拷贝数据之间实时性增强。
       (2)不要需要重复发起IO调用，但是需要在代码当中增加自定义信
       号的逻辑。
      （3）代码更加复杂，流程控制更难
    
   四、异步IO：由内核在数据拷贝完成时，通知应用程序（信号驱动是告
   诉应用程序何时可以开始拷贝数据）。
    
    1.原理：
      （1）自定义信号的处理函数--》作用是通知数据拷贝完成
      （2）发起一个异步调用，并且异步调用直接返回。
      （3）对于异步调用返回之后，执行流可以执行用户代码，由操作系
      统内核帮助我们等待IO就绪和拷贝数据
      （4）当拷贝数据都完成了，内核通过信号来通知调用者
        
    2特点:
      （1）异步IO模型中，数据拷贝过程也被内核完成了。
      （2）自定义信号处理函数导致代码复杂，流程复杂。
      （3）同阻塞IO，实时性没有受到到多大影响。

*小结：
  阻塞和非阻塞：
    资源不可用时，发起IO调用，当前IO调用是否返回。
      IO调用返回：则认为是非阻塞
      IO调用未返回：非阻塞
    同步和异步:
      区别于线程中的同步和互斥当中的同步。线程的同步指，让多个执
      行流合理访问临界资源，同步和异步IO当中的同步指：数据拷贝过
      程是否有程序员完成。
        是程序员完成：同步
        内核完成:异步
        是调用者等待资源：同步
        内核等待:异步
 
    五、IO多路转接（多路复用）： 从流程上看和阻塞IO类似，实际上最
    核心在于IO多路转接能够同时等待多个文件描述符的就绪状态。
    
    1.作用：
      （1）IO多路转接可以完成大量描述符的监控，监控的事件：可读事
      件，可写事件，异常事件。
      （2）当使用多路转接的时候，多路转接接口发现了某一个文件描述
      符就绪的时候，就会通知进程，让进程针对某一个描述符进行操作
      。其他描述符继续监控。
    2.好处：
      避免了进程对其他没有就绪的文件描述符进行操作，从而陷入阻塞
      情况。
    
    3.select：系统提供select函数来实现多路复用输入/输出模型
      
      3.1作用：
      （1）select系统调用是用来让我们的程序监视多个文件描述如的状
      态变化的。
      （2）程序会停在select这里等待，直到被监视的文件描述符有一个
      或多个发生了状态改变。
      
      （将用户关系描述符拷贝到内核，内核帮助用户进行监控）
      （如果内核监控到某个文件描述符事件准备就绪，则返回该描述符
      ）
      （用户针对描述符进行操作）

     3.2 select函数原型：
      int select(int nfds,fd_set* readfds,fd_set* writefds,fd_set* exceptfds,struct timeval* timeout);
      （1）nfd:取值为监控最大描述符数值+1 (小于1024)
          提高select的监控效率（监控哪些描述符，其底层是位图，0-
          1023，当传入最大描述符+1，则只需用监控到最大描述符+1
          的位置，并非监控整个范围，所以有利于效率）

      （2）使用select的时候，会传入3个事件的集合
        readset（可读事件集合） writeset（可写事件集合）excpetset（异常事件集合）
        
      （3）timeout取值：
      struct timeval{
          long tv_sec//秒级
          long tv_usec//微秒级
      }
          
          NULL：表示select()没有timeout，select将一致被阻塞，直到某个文件描述符上发生了事件。
          0：仅检测描述符集合的状态，然后立即返回，并不等待外部事
          件的发生。
          特定的时间值：如果在指定时间段里没有事件发生，select将超时返回。

      （4）返回值：
              大于0：则返回就绪的文件描述符的个数
              等于0：等待超时了
              小于0：监控出错
注意：select返回的时候，会将没有就绪的文件描述符从事件合中去除掉，
只返回就绪的文件描述符。（这样就能直到哪些文件描述符就绪，对其操作）

    3.3 4个操作fd_set位图的函数：
        void FD_CLR(int fd,fd_set* set);//从事件集合中删除某一个文件描述符
        
        int FD_ISSET(int fd,fd_set*set);//判断fd描述符，是否在set集合当中
        0：表示没有在集合当中 非0：表示在集合当中
        
        void FD_SET(int fd,fd_set*set);//设置fd到集合set中
        
        void FD_ZERO(fd_set* set);//清空位图
      
select优缺点:
  优点:
    1.select遵循的是posix标准，可跨平台移植
    2.select的超时时间可以精确到微妙
  缺点:
    1.select是轮询遍历的，监控的效率会随着文件描述符的增多而下降
    2.select所监控的文件描述符有上限，上限为1024个（0-1023），取决于内核当中_FD_SETSIZE宏的值
    3.select监控文件描述符的时候，需要将集合拷贝到内核当中，监控
    到文件描述符上有事件就绪的时候，同样需要从内核当中拷贝到用户
    空间，效率会受到影响。
    4.select在返回就绪文件描述符的时候，会将未就绪的文件描述符移
    除，导致第二次在去监控的时候，需要重新添加
    5.select没有直接告诉程序员哪一个文件描述符就绪了，需要程序员
    自己在返回时间当中去判断。

-----------------------------------------------------------------
 补充一下信号相关知识：
   1.信号的捕捉:
      （1）在执行主控制流程的某条指令时，因为中断、异常或者系统调
      用进入内核。
      （2）内核处理完异常准备回用户模式之前，先处理当前进程中可以
      递送的信号。do_signal()
      （3）如果信号的处理动作是自定义的信号处理函数，则回到用户模
       式执行信号处理（而不是回到主控制流程）。
      （4）信号处理函数返回时执行特殊的系统调用，再次进入内核
      （5）返回用户模式，从主控制流程中上次被中断的地方继续向下执
      行。

  2.信号捕捉函数：
    （可以使用kill -l 查看系统定义的信号列表）
    #include<signal.h>
    void(*signal(int signum,void(*handler)(int)))(int)
    函数说明:（实质就是改变信号signum的函数地址为handler，在signu
    m信号来的时候，回调hander指向的函数）
        1.signal()会依参数signum指定的信号编号来设置该信号的处理
        函数。当指定的信号到达时，就会跳转到handler指定的函数执行
        。如果handler不是函数指针，则必须是下列两个长属之一：
          SIG_IGN 忽略参数signum指定的信号
          SIG_DFL 将参数signum指定的信号重设未核心预设的信号处理
          方式。
      2.返回值返回先前的信号处理函数，如果有错误则返回SIG_ERR(-1)
      3.信号在发生跳转到自定义的handler处理函数执行后，系统会自动
     将此函数换回原来系统预设的处理方式。

  3.sigaction（查询或设置信号处理方式）
    #include<signa.h>
    int sigaction(int signum,const struct sigaction*act,struction*oldact);
    函数说明:
      sigaction()会依参数signum指定的信号编号来设置该信号的处理函
      数。参数signum可以指定SIGKILL和SIGSTOP以外的所有信号

    sigaction定义如下:
        struct sigaction{
         void (*sa_handler) (int);
         sigset_t sa_mask;
         int sa_flags;
         void (*sa_restorer) (void);
        };
sa_handler:此参数和signal()参数的handler相同，代表新的信号处理函
数
sa_mask 用来设置在处理该信号时暂时将sa_mask指定的信号搁置。
sa_restorer 此参数未使用
sa_flags 用来设置信号处理的其他相关操作。 用or(|)或运算组合
成功返回0 如果有错误返回1
-----------------------------------------------------------------

    










