**线程分离：
  设置线程的joinable属性为detach属性，程序不用关心线程退出的时候，线程由于joinable属性带来的内存泄漏的问题，原因是线程的detach，可以使退出的线程不需要其他线程回首自己的资源，退出的线程资源可以被操作系统所回收
  pthread_detach(pthread_t thread)
	thread:该线程标识符指的是分离那一个线程(设置哪一个线程的joinable属性被detach属性)
	
**线程安全：
  多个线程同时运行，访问临界资源，不会导致程序的结果产生二义性
   临界资源：多个线程执行流共享的资源就叫做临界资源。在同一时刻，该资源只能被一个线程（执行流）所访问。
   临界区：每个线程内部，访问临界资源的代码，就叫做临界区
   访问:在临界区当中对临界资源进行非原子操作
   原子操作：不会被任何调度机制打断的操作。操作是一步完成的，当前操作只有两个结果，要么完成 要么失败
   

**如何保证我们写出来的代码是线程安全的？
  互斥：保证在同一时刻只能有一个执行流访问临界资源
  同步：保证程序对临界资源的合理访问

  互斥锁:
    使用互斥锁来保证互斥属性
	互斥锁的底层是一个互斥量，互斥量本质上是一个计数器，该技术器只有两个取值0/1
	0代表，无法获取互斥锁，进而表示需要访问的临界资源不可以被访问
	1代表，可以获取互斥锁，进而表示需要访问的临界资源可以被访问

	例子：
	 int g_val = 10;
	 想要对g_val进行--操作

	 执行流A：
	  加锁--》使用互斥锁提供的加锁的接口，用来获取互斥锁资源
	   1.互斥锁计数器值为1，表示可以获取互斥锁，获取互斥锁的接口就正常返回，访问临界资源；
	   2.互斥锁计数器值为0，表示不可以获取互斥锁的接口进行阻塞等待
	   g_val--;

	   解锁


 加锁操作：对于互斥锁当中的互斥量保存的计数器进行-1操作
 解锁操作：对于互斥锁当中的互斥量保存的计数器进行+1操作

 **互斥量计数器本身也是一个变量，这个变量的取值为0/1，对于这样一个变量进行+-操作时，如何保证其的原子性呢？
  mutex_val: 0/1
  mutex_val = mutex_val-1 //加锁
  mutex_val = mutex_val+1 //解锁

  第一种情况： 寄存器：0  内存：1  还没有一个执行流进行加锁操作
  第二种情况： 寄存器：0  内存：0  已经有一个执行流进行加锁操作了

  *不论哪一种情况，都会将寄存器当中的值变为0
  加锁的时候：将寄存器中的值和内存当中的值进行互换，互换的指令为xchgb(汇编)，而这种互换操作是原子性的，一步完成
  当交换完毕之后，需要对寄存器当中的值进行判断：
    如果寄存器当中的值为0，则表示不能加锁，意味着当前的加锁操作会被阻塞，从而无法访问临界资源。
	如果寄存器当中的值为1，则表示可以加锁，对计数器进行-1操作后，获得所资源，并且加锁操返回，从而访问临界资源。

	总结：
	当计数器的值为1，表示可以加锁操作，当寄存器和内存的值进行一步交换之后，相当于给计数器进行-1操作了
    当计数器的值为0，表示不可以加锁，当寄存器和内存的值进行一步交换以后，并没有对计数器当中的值做到真实修改。当前执行流就被挂起等待

