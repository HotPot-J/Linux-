TCP协议报头当中的序号和确认序号

	客户端与服务端各维护一套号，范围是0-2^32，在三次握手时，起始序号是随机的。
	1.对于一次三次握手而言，双方发送第一个数据包的时候(其实
	就是SYN报文或者SYN+ACK报文)，是协商彼此的起始序号的位置
	，对于每一个连接双方而言，自己方管理的序号不一定是从0开始
	的。
	2.对于只有ACK，其作用只是确认的，是不消耗序号的。、
	 而捎带应带，是序号的，比如psh+ack 就会消耗

*描述一次TCP从建立连接到发送数据序列号的变化过程：

三次握手建立连接的过程：
 cli：-----(SYN(seq=0))----->svr
 svr:------(ACK(ACK=1)+SYN(seq=0))--->cli
*此时客户端告诉服务端自己的起始序号是从0开始，并消耗掉了0,此时有效序号范围是(1-2^32)
*此时服务端确认收到了客户端发送的SYN报文,而客户端发送的SYN序号为0，确认的时候告诉客户端,你维护的序号位0的数据我收到了,并且期待你序号为1的数据报。并且服务端告诉客户端，自己的起始序号
从0开始，并且消耗掉了0，现在有效范围是(1-2^32)
cli---(ACK(seq=1,ACK=1))--->svr
*此时客户端确认收到了服务端发送的序号为0的数据包，并且告诉服务端，接下来期望服务端给自己发送的数据包序从1开始。
seq = 1：表示客户端告诉服务端，说这个ACK数据的客户端维护的序号是1，但是由于我是一个ACK，所以并没有消耗掉这个‘1’序号

三次握手完成后：
	对于客户端： SYN-》消耗了0
				 ACK--》没有消耗掉1
		此时客户端维护的序号有效范围：1-2^32
	对于服务端：SYN+ACK消耗掉了服务端维护的0序号
		此时服务端维护的序号有效范围：1-2^32

*发送数据的过程:
	cli----(PSH(seq=1,ack=1)))--->svr
	svr----(ACK(ACK=6,seq=1)-->cli
对于cli：由于发送数据的时候seq是该条数据的起始序号，整体消耗序号 = 起始序号+数据长度-1,
ACK=1是期待对端下一条数据的起始序号为1
对于svr:回复确认序号时：确认序号（作用是告诉对端自己期望的下一个序号是哪个) = 客户端发送过来的数据的起始序号Seq(cli)+数据长度
seq=1我当前维护的序号为1

*当客户端连接服务端的时候，发送第一个SYN报文，在很长时间内，没
有收到SYN+ACK报文，从而重新连接对端。在第二次发起连接之后，同
时收到了两个SYN+ACK报文，对客户端而言，如何来进行区别？
	发起端：              接收端：
	     ---SYN(Seq=100)--->
		  （接收端未回复）
再次     ---SYN(Seq=120)--->
此时发起端 收到：SYN+ACK(101) SYN+ACK(121)
	此时发起端用确认序号去区别，认为第二次发送的SYN收到的SYN+
	ACK的确认序号有效。



