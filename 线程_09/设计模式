设计模式：
	针对一些常见的问题或常见的场景，给出一种解决方案，设计成为一种套路。、

设计模式的优点：
	代码复用成都高 
	程序比较可靠，并且容易理解
	代码框架比较稳定

设计模式的分类：
	创建型模式---》单例模式
	结构型模式---》适配器模式
	行为型模式---》观察者模式

单例模式：
	
	1.特点：全局提供唯一一个类的实例，具有全局变量的特点
	
	2.使用场景：内存池，数据池
	
	3.基础要点
		全局只有一个实例---》static + 禁止拷贝构造+禁止复制拷贝
		线程安全
		调用者是通过类的函数来获取实例
	
	4.具体实现
		
		饿汉模式：
			（相当于每次吃完饭就洗碗，下次直接能用）
			程序启动的时候进行初始化，资源在程序初始化的时候就加载完毕了；
				优点：程序运行速度快，流畅
				缺点：程序初始化的时候耗时较长
       template<Typename T>
		class singleton
        { 
		
		   private：
			   static data;
		   public:
				static T* GetInstance()
				{
				  return &data;
				}
		};
			
		懒汉模式：
			（相当于每次吃完饭不洗碗，第二次吃饭的时候，才洗碗）
		资源在使用的时候才进行实例化，单例类的对象在使用时才进行初始化   
				优点：程序初始化的时候比较快
				缺点：运行的时候没有饿汉模式流畅 存在线程安全问题

		temolate<typname T>
		class singleton
        {
		  volatile static* T inst; //需要设置volatile关键字，否则可能会被编译器优化
		  static std::mutex lock;
		  
		public:
		   static T* GetInstance(){
		     if(inst == NULL){ //双重判定空指针，降低锁冲突的概率，提高性能
			   lock.lock();//使用互斥锁，保证多线程情况下也只调用一次new
			   if(inst == NULL){
			     inst = new T();
			   }
			   lock.unlock();
			 }
			 return inst;
		   } 
		};
 1.互斥锁保证安全
 2.双重if提高性能
 3.volatile关键字防止过度优化

 
 常见的一些锁：
	1.悲观锁：在每次取数据时，总是担心数据会被其他线程修改，所以会在取数据
	前先加锁，当其他线程想要访问数据时会被阻塞挂起。

	2.乐观锁：在每次获取数据的时候，总乐观的认为数据不会被其他线程修改，因
	此不上锁。但是在更新数据前，会判断其他数据在更新前有没有对数据进行修改
	。主要采取两种方式:版本号机制和CAS操作

	CAS操作: 当需要更新数据时，判断当前内存值和之前取得的值是否相等。如果
	相等则用新值更新，若不等则失败，失败则重试，一般是一个自旋的过程，即
	不断重试。
	CAS涉及三个操作数：需要读写的内存值V，进行比较的值A，拟写入的值B
	例子：当内存值V = 10 ，想要修改V的过程
	1.先获取V，赋值给值A
	2.想要更改时，比较A是否等于当前内存中的V  等于（V没被修改过），则可以交换
	不等于：不可交换，重新获取值A
	3.交换 将新值B，写入V中
		将新值B，写入到V中
			
